
"use client";

import React, { useState, useCallback, useEffect, useRef } from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardFooter } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { Label } from '@/components/ui/label';
import { Slider as SliderComponent } from '@/components/ui/slider';
import { Save, Trash2, Plus } from 'lucide-react';
import { addToHistory } from '@/lib/history';
import { useToast } from '@/hooks/use-toast';
import { create, all, type MathNode } from 'mathjs';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Separator } from '@/components/ui/separator';
import { GraphToolsSidebar, type Tool } from './graph-tools-sidebar';

// Setup mathjs instance
const math = create(all);

// #region Type Definitions
// The `isDerived` property is used to distinguish points created by the user
// from points generated by analysis tools (like Roots, Intersect, etc.).
type Point = {
  id: string;
  type: 'point';
  x: number;
  y: number;
  label: string;
  isDerived?: boolean;
};

type Func = {
  id: string;
  type: 'function';
  expression: string;
  compiled: ReturnType<MathNode['compile']>;
  color: string;
};

type Slider = {
  id: string;
  type: 'slider';
  name: string;
  min: number;
  max: number;
  step: number;
  value: number;
};

type GraphObject = Point | Func | Slider;

type ViewTransform = {
  x: number; // pan x
  y: number; // pan y
  zoom: number;
};
// #endregion

export function GraphCalculator() {
  const canvasRef = useRef<HTMLCanvasElement>(null);

  const [objects, setObjects] = useState<GraphObject[]>([]);
  const [activeTool, setActiveTool] = useState<Tool>('move');
  const [viewTransform, setViewTransform] = useState<ViewTransform>({ x: 0, y: 0, zoom: 50 });
  const [isDragging, setIsDragging] = useState(false);
  const lastMousePos = useRef({ x: 0, y: 0 });

  const { toast } = useToast();

  // #region Core Drawing & Transformation Logic
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    // Resize canvas to fit container
    const { width, height } = canvas.getBoundingClientRect();
    if (canvas.width !== width || canvas.height !== height) {
      canvas.width = width;
      canvas.height = height;
    }

    const { x: panX, y: panY, zoom } = viewTransform;
    let animationFrameId: number;
    
    const render = () => {
      ctx.clearRect(0, 0, width, height);

      ctx.save();
      ctx.translate(width / 2 + panX, height / 2 + panY);
      ctx.scale(zoom, -zoom);

      const viewBounds = {
        minX: - (width / 2 + panX) / zoom,
        maxX: (width / 2 - panX) / zoom,
        minY: - (height / 2 - panY) / zoom,
        maxY: (height / 2 + panY) / zoom,
      };

      drawGrid(ctx, viewBounds, zoom);
      drawAxes(ctx, viewBounds);
      
      const scope = objects.filter(o => o.type === 'slider').reduce((acc, s) => ({ ...acc, [(s as Slider).name]: (s as Slider).value }), {});
      objects.forEach(obj => {
        if (obj.type === 'function') drawFunction(ctx, obj, viewBounds, scope);
        if (obj.type === 'point') drawPoint(ctx, obj);
      });

      ctx.restore();
      animationFrameId = window.requestAnimationFrame(render);
    };

    render();

    return () => {
      window.cancelAnimationFrame(animationFrameId);
    };
  }, [objects, viewTransform]);

  const worldToScreen = (x: number, y: number) => {
    const canvas = canvasRef.current;
    if (!canvas) return { x: 0, y: 0 };
    const { width, height } = canvas;
    return {
      x: x * viewTransform.zoom + width / 2 + viewTransform.x,
      y: -y * viewTransform.zoom + height / 2 + viewTransform.y
    };
  };

  const screenToWorld = (x: number, y: number) => {
    const canvas = canvasRef.current;
    if (!canvas) return { x: 0, y: 0 };
    const { width, height } = canvas;
    return {
      x: (x - width / 2 - viewTransform.x) / viewTransform.zoom,
      y: -(y - height / 2 - viewTransform.y) / viewTransform.zoom
    };
  };
  // #endregion

  // #region Canvas Drawing Helpers
  const drawGrid = (ctx: CanvasRenderingContext2D, bounds: any, zoom: number) => {
    ctx.beginPath();
    ctx.strokeStyle = 'hsl(var(--border))';
    ctx.lineWidth = 1 / zoom;
    const step = Math.pow(10, Math.floor(Math.log10(bounds.maxX - bounds.minX)) - 1);
    for (let x = Math.floor(bounds.minX / step) * step; x <= bounds.maxX; x += step) {
        ctx.moveTo(x, bounds.minY);
        ctx.lineTo(x, bounds.maxY);
    }
    for (let y = Math.floor(bounds.minY / step) * step; y <= bounds.maxY; y += step) {
        ctx.moveTo(bounds.minX, y);
        ctx.lineTo(bounds.maxX, y);
    }
    ctx.stroke();
  };

  const drawAxes = (ctx: CanvasRenderingContext2D, bounds: any) => {
    ctx.beginPath();
    ctx.strokeStyle = 'hsl(var(--foreground))';
    ctx.lineWidth = 2 / viewTransform.zoom;
    ctx.moveTo(bounds.minX, 0);
    ctx.lineTo(bounds.maxX, 0);
    ctx.moveTo(0, bounds.minY);
    ctx.lineTo(0, bounds.maxY);
    ctx.stroke();
  };
  
  const drawFunction = (ctx: CanvasRenderingContext2D, func: Func, bounds: any, scope: any) => {
    ctx.beginPath();
    ctx.strokeStyle = func.color;
    ctx.lineWidth = 2 / viewTransform.zoom;
    let firstPoint = true;
    for (let sx = 0; sx <= ctx.canvas.width; sx++) {
        const x = screenToWorld(sx, 0).x;
        try {
            const y = func.compiled.evaluate({ ...scope, x });
            if (Number.isFinite(y)) {
                if (firstPoint) {
                    ctx.moveTo(x, y);
                    firstPoint = false;
                } else {
                    ctx.lineTo(x, y);
                }
            }
        } catch (e) { /* ignore */ }
    }
    ctx.stroke();
  };

  // The `drawPoint` function now checks for the `isDerived` flag to style
  // analysis points (like roots) differently from user-created points.
  const drawPoint = (ctx: CanvasRenderingContext2D, point: Point) => {
    ctx.beginPath();
    if (point.isDerived) {
        ctx.fillStyle = 'hsl(var(--accent))';
        ctx.arc(point.x, point.y, 5 / viewTransform.zoom, 0, 2 * Math.PI);
    } else {
        ctx.fillStyle = 'hsl(var(--primary))';
        ctx.arc(point.x, point.y, 4 / viewTransform.zoom, 0, 2 * Math.PI);
    }
    ctx.fill();
  };
  // #endregion

  // #region Tool Logic & Event Handlers
  
  /**
   * HOW TO ADD A NEW TOOL:
   * 1. Add the tool ID to the `Tool` type in `graph-tools-sidebar.tsx`.
   * 2. Add the tool's UI configuration (icon, label) to `toolConfig` in `graph-tools-sidebar.tsx`.
   * 3. Add a `case` for your new tool's ID in the `switch` statement within the `handleMouseUp` function below.
   * 4. Implement the tool's logic inside its `case`. This may involve:
   *    - Getting the click position (`worldPos`).
   *    - Finding nearby graph objects (functions, points).
   *    - Performing calculations (e.g., distance, midpoint, derivative).
   *    - Adding new derived objects (like points or lines) to the `objects` state.
   */

  const findRoots = useCallback((func: Func, bounds: any, scope: any) => {
    const { minX, maxX } = bounds;
    const roots: { x: number; y: number }[] = [];
    const compiledFunc = (x: number) => func.compiled.evaluate({ ...scope, x });

    const bisection = (f: (x: number) => number, a: number, b: number, tol = 1e-7, maxIter = 100) => {
      let fa = f(a);
      if (Math.abs(fa) < tol) return a;
      let fb = f(b);
      if (Math.abs(fb) < tol) return b;
      if (fa * fb >= 0) return null;
      let c = a;
      for (let i = 0; i < maxIter; i++) {
        c = (a + b) / 2;
        let fc = f(c);
        if (fc === 0 || (b - a) / 2 < tol) return c;
        if (fa * fc < 0) { b = c; } else { a = c; fa = fc; }
      }
      return c;
    };

    const step = (maxX - minX) / 500;
    for (let x = minX; x < maxX; x += step) {
      try {
        const y1 = compiledFunc(x);
        const y2 = compiledFunc(x + step);
        if (y1 * y2 < 0) {
          const rootX = bisection(compiledFunc, x, x + step);
          if (rootX !== null) roots.push({ x: rootX, y: 0 });
        }
      } catch (e) { /* ignore */ }
    }
    
    if(roots.length > 0) {
      const newPoints: Point[] = roots.map(r => ({
          id: crypto.randomUUID(), type: 'point', x: r.x, y: r.y,
          label: `Root (${r.x.toFixed(2)})`, isDerived: true,
      }));
      setObjects(prev => [...prev.filter(o => !(o.type === 'point' && o.isDerived)), ...newPoints]);
      toast({ title: `Found ${newPoints.length} root(s).` });
    } else {
      toast({ variant: 'destructive', title: 'No roots found in the current view.' });
    }
  }, [toast]);
  
  const handleMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => {
    setIsDragging(true);
    lastMousePos.current = { x: e.clientX, y: e.clientY };
  };

  const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!isDragging || activeTool !== 'move') return;
    const dx = e.clientX - lastMousePos.current.x;
    const dy = e.clientY - lastMousePos.current.y;
    lastMousePos.current = { x: e.clientX, y: e.clientY };
    setViewTransform(v => ({ ...v, x: v.x + dx, y: v.y + dy }));
  };

  const handleMouseUp = (e: React.MouseEvent<HTMLCanvasElement>) => {
    const wasDragging = (Math.abs(e.clientX - lastMousePos.current.x) > 2 || Math.abs(e.clientY - lastMousePos.current.y) > 2);
    setIsDragging(false);
    if (wasDragging && activeTool === 'move') return;

    const rect = canvasRef.current!.getBoundingClientRect();
    const worldPos = screenToWorld(e.clientX - rect.left, e.clientY - rect.top);

    switch (activeTool) {
      case 'point':
        addPoint(worldPos.x, worldPos.y);
        break;
      case 'roots': {
        let closestFunc: Func | null = null;
        let minDistance = Infinity;
        const scope = objects.filter(o => o.type === 'slider').reduce((acc, s) => ({ ...acc, [(s as Slider).name]: (s as Slider).value }), {});
        objects.forEach(obj => {
          if (obj.type === 'function') {
            try {
              const y = obj.compiled.evaluate({ ...scope, x: worldPos.x });
              const distance = Math.abs(y - worldPos.y);
              if (distance < minDistance) {
                minDistance = distance;
                closestFunc = obj;
              }
            } catch (e) {}
          }
        });

        if (closestFunc && minDistance < 1 / viewTransform.zoom * 20) { // Click tolerance
          const viewBounds = {
            minX: screenToWorld(0, 0).x,
            maxX: screenToWorld(canvasRef.current!.width, 0).x,
          };
          findRoots(closestFunc, viewBounds, scope);
        } else {
          toast({ variant: 'destructive', title: 'No function selected', description: 'Click closer to a function to find its roots.' });
        }
        break;
      }
    }
  };

  const handleWheel = (e: React.WheelEvent<HTMLCanvasElement>) => {
    const zoomFactor = 1.1;
    const newZoom = e.deltaY < 0 ? viewTransform.zoom * zoomFactor : viewTransform.zoom / zoomFactor;
    setViewTransform(v => ({ ...v, zoom: Math.max(0.1, newZoom) }));
  };
  // #endregion

  // #region Object Management
  const addObject = (type: 'function' | 'slider') => {
    if (type === 'function') {
        const newFunc: Func = {
            id: crypto.randomUUID(), type: 'function', expression: 'x^2',
            compiled: math.parse('x^2').compile(), color: `hsl(${Math.random() * 360}, 70%, 50%)`,
        };
        setObjects(prev => [...prev, newFunc]);
    } else if (type === 'slider') {
        const sliderName = String.fromCharCode(97 + objects.filter(o => o.type === 'slider').length);
        const newSlider: Slider = {
            id: crypto.randomUUID(), type: 'slider', name: sliderName,
            min: -5, max: 5, step: 0.1, value: 1,
        };
        setObjects(prev => [...prev, newSlider]);
    }
  };

  const addPoint = (x: number, y: number) => {
    const newPoint: Point = {
        id: crypto.randomUUID(), type: 'point', x, y,
        label: `(${x.toFixed(2)}, ${y.toFixed(2)})`
    };
    setObjects(prev => [...prev, newPoint]);
  };

  const updateObject = (id: string, updates: Partial<GraphObject>) => {
    setObjects(prev => prev.map(obj => {
      if (obj.id === id) {
        const updatedObj = { ...obj, ...updates };
        if (updatedObj.type === 'function' && 'expression' in updates) {
          try {
            updatedObj.compiled = math.parse(updatedObj.expression).compile();
          } catch(e) {
            toast({ variant: 'destructive', title: 'Invalid expression' });
          }
        }
        return updatedObj;
      }
      return obj;
    }));
  };

  const deleteObject = (id: string) => {
    setObjects(prev => prev.filter(obj => obj.id !== id));
  };
  
  const handleSave = () => {
    const dataToSave = {
        objects: objects.map(o => o.type === 'function' ? { ...o, compiled: undefined } : o),
        viewTransform,
    };
    addToHistory({ type: 'graph', data: dataToSave, name: `Saved Interactive Graph` });
    toast({ title: "Saved!", description: "Graph saved to history." });
  };
  // #endregion

  return (
    <div className="h-full w-full flex">
      <GraphToolsSidebar activeTool={activeTool} setActiveTool={setActiveTool} />
      
      <Card className="w-80 h-full flex flex-col rounded-none border-0 border-r shrink-0">
        <CardHeader>
          <CardTitle>Objects</CardTitle>
        </CardHeader>
        <CardContent className="flex-grow overflow-hidden">
          <ScrollArea className="h-full pr-4">
            <div className="space-y-4">
              <div>
                <Label className="text-lg font-semibold">Functions</Label>
                {objects.filter(o => o.type === 'function').map(obj => {
                    const func = obj as Func;
                    return (
                        <div key={func.id} className="flex items-center gap-2 mt-2">
                          <Input type="color" value={func.color} onChange={e => updateObject(func.id, { color: e.target.value })} className="p-1 h-8 w-8" />
                          <Input value={func.expression} onChange={e => updateObject(func.id, { expression: e.target.value })} />
                          <Button variant="ghost" size="icon" onClick={() => deleteObject(func.id)}><Trash2 className="h-4 w-4" /></Button>
                        </div>
                    );
                })}
                <Button onClick={() => addObject('function')} variant="outline" size="sm" className="mt-2"><Plus className="h-4 w-4 mr-2" />Add Function</Button>
              </div>
              <Separator />
              <div>
                <Label className="text-lg font-semibold">Sliders</Label>
                 {objects.filter(o => o.type === 'slider').map(obj => {
                    const slider = obj as Slider;
                    return (
                        <div key={slider.id} className="mt-2 space-y-2">
                           <div className="flex justify-between items-center">
                             <Label className="font-mono text-lg">{slider.name} = {slider.value}</Label>
                             <Button variant="ghost" size="icon" onClick={() => deleteObject(slider.id)}><Trash2 className="h-4 w-4" /></Button>
                           </div>
                           <SliderComponent
                                value={[slider.value]} min={slider.min} max={slider.max} step={slider.step}
                                onValueChange={([val]) => updateObject(slider.id, { value: val })}
                            />
                        </div>
                    );
                })}
                <Button onClick={() => addObject('slider')} variant="outline" size="sm" className="mt-2"><Plus className="h-4 w-4 mr-2" />Add Slider</Button>
              </div>
               <Separator />
               <div>
                <Label className="text-lg font-semibold">Points</Label>
                 <div className='space-y-1 mt-2 text-sm'>
                 {objects.filter(o => o.type === 'point').map(obj => {
                    const point = obj as Point;
                    return (
                        <div key={point.id} className="flex justify-between items-center">
                           <span>{point.label}</span>
                           <Button variant="ghost" size="icon" onClick={() => deleteObject(point.id)} className='h-6 w-6'><Trash2 className="h-4 w-4" /></Button>
                        </div>
                    );
                })}
                 </div>
              </div>
            </div>
          </ScrollArea>
        </CardContent>
        <CardFooter className="flex-col items-start gap-2">
           <Button onClick={handleSave} variant="outline"><Save className="h-4 w-4 mr-2" />Save Graph</Button>
        </CardFooter>
      </Card>
      
      <div className="flex-grow h-full relative">
        <canvas
          ref={canvasRef}
          className="w-full h-full cursor-crosshair"
          onMouseDown={handleMouseDown}
          onMouseMove={handleMouseMove}
          onMouseUp={handleMouseUp}
          onMouseLeave={() => setIsDragging(false)}
          onWheel={handleWheel}
        />
      </div>
    </div>
  );
}
